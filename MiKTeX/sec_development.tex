\section{Проектирование программного средства} % (fold)
\label{sec:development}

Разрабатываемым программное средство, как было отмечено в пункте \ref{sub:domain:requirements:langs}, было разбито на три независимых модуля.
Каждый модуль разрабатывался отдельно. Модули обмениваются данными в определенном бинарном формате.
Это позволяет сторонним приложениям легко интегрироваться с разрабатываемым ПС путем реализации чтения описанных ниже бинарных форматов.

В данном разделе будут подробно рассмотрены все модули, используемые в разрабатываемом ПС, а также будут описаны бинарные форматы обмена данными.

\subsection{Модуль чтения и разбора схемы сооружения и сценария симуляции}
\label{sec:development:preprocessor}

Модуль чтения и разбора схемы сооружения и сценария симуляции выполнен на языке программирования Ruby.
В его задачи входит:
\begin{itemize}
  \item разбор сценария симуляции на отдельные компоненты;
  \item разбор схемы сооружения на отдельные компоненты;
  \item формирование сообщения о конфигурации модулю выполнения симуляции в определенном бинарном формате.
\end{itemize}

\subsubsection{Сценарий симуляции}
\label{sec:development:preprocessor:scenario_dsl}

Благодаря гибкости языка Ruby и его широких возможностей в метапрограммировании,
сценарий симуляции выполнен в виде предметно"=ориентированного языка (DSL "--- Domain Specific Language).

Пример сценария симуляции представлен в листинге~\ref{sec:development:preprocessor:scenario_dsl_listing}.

\lstinputlisting[language=Ruby,caption={Пример сценария симуляции}, label=sec:development:preprocessor:scenario_dsl_listing, texcl=true]{sim_params_example.rb}

В сценарии симуляции указывается множество различных параметров симуляции.
Более подробно данный язык и каждый его параметр будут рассмотрены в разделе~\ref{sec:development:manual:scenario_sdl}.
В данном разделе остановимся на рассмотрении вопросов, связанных с реализацией данного предметно"=ориентированного языка.

Основой разработанного модуля является класс Sections::Base. Он представляет собой базовый класс для определения секции в файле сценария симуляции.
Данный класс определяет статический метод field, который добавляет во внутренние переменные класса предоставленную информацию о поле сценария симуляции,
а также средствами метапрограммирования Ruby (в частности, с помощью метода define\_method) объявляет в вызывающем классе метод с именем, соответствующим имени поля.
Данный метод при вызове получает некоторое значение поля и сохраняет его во внутренней переменной объекта класса.
Таким образом, файл сценария симуляции по сути является файлом с Ruby кодом, который вызывает объявленные ранее методы с именами полей.

Поддерживаются следующие типы полей: целое число, число с плавающей точкой, строка, булевый флаг, потомок, распределение и динамический тип.

Потомок "--- особый тип поля, которому в параметрах передается имя класса, отвечающего за дальнейший разбор предоставленных параметров.
Данный тип поля использует такую особенность языка Ruby, как блоки, которые являются реализацией общей концепции замыканий.
В языке Ruby существует четыре концепции, описывающие некоторую совокупность кода "--- это block, Proc, lambda и method.

Proc "--- объект, описывает некоторую абстрактную совокупность кода. Он может быть сохранен в отдельную переменную. Доступ к коду, который хранит Proc, осуществляется с помощью метода call(args).
Lambda по своей сути практически не отличается от объекта Proc. Отличиями являются наличие контроля за передаваемыми аргументами и другое поведение оператора return внутри лямбды.
Method "--- объект-обертка над Lambda. Используется для хранения методов внутри класса. Так же как Proc и lambda, использует метод call(args) для доступа к коду.

Блоки в руби являются своеобразным синтаксическим сахаром над описанными выше концепциями.
Они позволяют унифицировать доступ к определенным совокупностям кода с помощью единого синтаксиса.
В частности, любой метод в руби может принимать дополнительный последний параметр, отмеченный специальным символом \&.
В случае, если метод был вызван с блоком, в данный параметр передается сконвертированная в объект Proc совокупность кода, находящаяся в блоке.
Так же в Ruby присутствует функция yield, которая вызывает код, переданный в блоке, с определенными параметрами.

Таким образом, поле типа <<потомок>> принимает на вход блок, и выполняет его содержимое в контексте определенного класса-потомка.

Распределение "--- еще один особый тип поля. Он очень похож на <<потомка>>, за исключением того, что переданный блок всегда выполняется в контексте определенного класса (Utils::Distribution),
который отвечает за формирование определенных полей в зависимости от типа распределения (равномерное, нормальное и др.).

Последний тип поля "--- динамический тип. Он позволяет обрабатывающему классу определить некоторую совокупность кода, которая будет осуществлять разбор предоставленного значения.
В качестве совокупности кода может выступать любая из четырех описанных выше концепций.

\subsubsection{Схема сооружения}
\label{sec:development:preprocessor:svg_scheme}

В качестве схемы сооружения используется особым образом модифицированный SVG файл.
SVG "--- распространенный формат векторной графики на основе XML.
Выбор SVG в качестве формата для представления схемы сооружения обусловлен следующими причинами:
\begin{itemize}
  \item распространенность формата SVG;
  \item легкость модификации SVG элементов путем добавления атрибутов к соответствующим XML тегам;
  \item легкость разбора SVG файлов на компоненты.
\end{itemize}

Пример схемы сооружения представлен в листинге~\ref{sec:development:preprocessor:svg_scheme_listing}.

\lstinputlisting[language=XML,caption={Пример схемы сооружения}, label=sec:development:preprocessor:svg_scheme_listing]{scene.svg}

В реализованном ПС поддерживаются два основных элемента SVG "--- line и rect.
При этом введены следующие дополнительные атрибуты:
\begin{itemize}
  \item x-csim-class;
  \item x-csim-id;
  \item x-csim-seq-no;
  \item x-csim-last.
\end{itemize}

Атрибут x-csim-class отвечает за тип данного элемента.
Возможные значения:
  wall (препятствие),
  spawn\_area (место появления людей),
  target\_area (место назначения людей "--- промежуточное или конечное).

Атрибут x-csim-id отвечает за идентификацию определенного логического элемента.
В частности, он используется для связывания цепочки мест появления и мест назначения в единый путь.

Атрибут x-csim-seq-no может быть применен только к элементу с типом target\_area и определяет порядковый номер промежуточной target\_area.

Атрибут x-csim-last определяет, является ли данное место назначения промежуточным или конечным.

Поле, задающее путь к файлу со схемой сооружения в сценарии симуляции, имеет динамический тип.
В качестве обработчика указан метод класса Sections::Scene parse\_scene\_file.
Данный метод осуществляет разбор схемы сооружения с использованием библиотеки разбора XML Crack, и сохраняет полученные геометрические элементы с их признаками.

\subsubsection{Формирование сообщения о конфигурации модулю выполнения симуляции}
\label{sec:development:preprocessor:format}

После разбора всех компонентов сценария симуляции модуль чтения и разбора должен сформировать сообщение о конфигурации модулю выполнения симуляции.
Для выполнения данной задачи каждый класс, представляющий собой секцию в файле конфигурации, обязан предоставить метод to\_config, который сформирует бинарную строку по определенному формату.
Данный метод вызывается рекурсивно для всех потомков, что позволяет на вершине дерева собрать все необходимое сообщение о конфигурации.

Формат описания конфигурации состоит из отдельных независимых друг от друга элементов.
Каждый элемент имеет следующую структуру:
\begin{itemize}
  \item идентификатор секции, к которой принадлежит данный элемент (1 байт);
  \item идентификатор элемента внутри данной секции (2 байта);
  \item данные элемента, закодированные в бинарном формате (переменное количество байт).
\end{itemize}

Подробно данные каждого элемента описаны в таблице~\ref{sec:development:preprocessor:format_table}.
Все координаты представлены двухбайтовыми целыми числами без знака, а перед каждой строкой записана ее длина.
Также используется формат распределения, который во всех случаях состоит из одного однобайтового целого без знака и двух чисел с плавающей точкой.
Первое число определяет тип распределения "--- равномерное (0x01) или нормальное (0x02).
В случае равномерного два числа с плавающей точкой означают границы <<от>> и <<до>> распределения,
а в случае нормального "--- среднее значение и среднеквадратичное отклонение соответственно.

\begin{longtable}[ht]{| >{\centering}m{0.25\textwidth}
                      | >{\centering}m{0.25\textwidth}
                      | >{\centering\arraybackslash}m{0.40\textwidth}|}
\caption{Формат сообщения о конфигурации} \label{sec:development:preprocessor:format_table}\tabularnewline

\hline Секция & Элемент & Данные элемента \tabularnewline
\endfirsthead
\captionsetup{labelformat=stbtablecont,justification=raggedright}
\caption[]{}\tabularnewline
\hline 1 & 2 & 3 \tabularnewline
\endhead
  \hline Сцена "--- 0x01 & Стена (препятствие) "--- 0x0001 & \specialcell{координаты первой точки\\
                                                                       (x0, y0)\\
                                                                       координаты второй точки\\
                                                                       (x1, y1)} \tabularnewline
  \hline Сцена "--- 0x01 & Место появления людей "--- 0x0002 & \specialcell{координаты первой точки\\
                                                                           (x0, y0)\\
                                                                           координаты второй точки\\
                                                                           (x1, y1)\\
                                                                           идентификатор пути (1 байт)} \tabularnewline
  \hline Сцена "--- 0x01 & Место назначения "--- 0x0003 & \specialcell{координаты первой точки\\
                                                                       (x0, y0)\\
                                                                       координаты второй точки\\
                                                                       (x1, y1)\\
                                                                       идентификатор пути\\
                                                                       (целое, 1 байт)\\
                                                                       порядковый номер\\
                                                                       (целое, 7 бит)\\
                                                                       флаг конечности (1 бит)} \tabularnewline
  \hline Сцена "--- 0x01 & Ширина, пикселей "--- 0x0011 & ширина (целое, 2 байта) \tabularnewline
  \hline Сцена "--- 0x01 & Высота, пикселей "--- 0x0012 & высота (целое, 2 байта) \tabularnewline
  \hline Сцена "--- 0x01 & Масштаб, метров на пиксель "--- 0x0013 & масштаб (с плавающей точкой, 8 байт) \tabularnewline
  \hline Сцена "--- 0x01 & Имя файла со сценой "--- 0x00FF & имя файла (строка) \tabularnewline

  \hline Параметры времени "--- 0x02 & Время окончания симуляции, секунд "--- 0x0001 & время (целое, 4 байта) \tabularnewline
  \hline Параметры времени "--- 0x02 & Единичный шаг времени, секунд "--- 0x0002 & шаг (с плавающей точкой, 8 байт) \tabularnewline

  \hline Параметры места появления "--- 0x03 & Скорость появления, человек в секунду "--- 0x0001 & скорость (с плавающей точкой, 8 байт) \tabularnewline

  \hline Параметры сил "--- 0x04 & Коэффициент отталкивания "--- 0x0101 & коэффициент (распределение) \tabularnewline
  \hline Параметры сил "--- 0x04 & Желаемая скорость передвижения "--- 0x0201 & скорость (распределение) \tabularnewline

  \hline Параметры поля зрения "--- 0x05 & Коэффициент переднего поля зрения "--- 0x0001 & коэффициент (с плавающей точкой, 8 байт) \tabularnewline
  \hline Параметры поля зрения "--- 0x05 & Коэффициент заднего поля зрения "--- 0x0002 & коэффициент (с плавающей точкой, 8 байт) \tabularnewline

  \hline Параметры определения плотности "--- 0x06 & Флаг включения "--- 0x0001 & \specialcell{флаг (1 байт)\\
                                                                                               1 "--- включено\\
                                                                                               0 "--- выключено} \tabularnewline
  \hline Параметры определения плотности "--- 0x06 & Минимальный порог плотности (ниже данного порога область не считается областью скопления) "--- 0x0002 & порог (с плавающей точкой, 8 байт) \tabularnewline
  \hline Параметры определения плотности "--- 0x06 & Максимальный порог плотности (выше данного порога области не различаются между собой по цвету) "--- 0x0003 & порог (с плавающей точкой, 8 байт) \tabularnewline

  \hline
\end{longtable}

\subsection{Модуль выполнения симуляции}
\label{sec:development:core}

Модуль выполнения симуляции разработан на языке программирования Rust.
В его задачи входит:
\begin{itemize}
  \item разбор и сохранение входного сообщения о конфигурации;
  \item выполнение симуляции по заданной конфигурации;
  \item в процессе выполнения непрерывно выдавать данные о текущем состоянии симуляции модулю отображения результатов.
\end{itemize}

\subsubsection{Разбор и сохранение конфигурации}
\label{sec:development:core:configuration}

Разбор и сохранение конфигурации осуществляется подмодулем con\-fi\-gu\-ra\-ti\-on.
Экспортируемыми элементами из данного модуля являются
функция new, которая осуществляет разбор предоставленной конфигурации и сохранение ее в новое хранилище,
макрос config, который получает значение определенного параметра из хранилища,
а также множество типов (структур и перечислений), используемых в качестве ключей для доступа к конфигурации.

В качестве хранилища для конфигурации была выбрана библиотека AnyMap.
Данная библиотека позволяет хранить по ключу в виде типа некоторое значение данного типа.
Соответственно, в модуле configuration объявлено по одному типу на каждый элемент конфигурации.

Основной цикл разбора конфигурации находится в функции par\-se\_con\-fig\_fi\-le.
Данная функция вызывает функцию par\-se\_sin\-gle\_item до тех пор, пока не останется ни одного необработанного элемента.

Функция parse\_single\_item читает из входного потока номер секции, и в зависимости от него вызывает одну из функций
par\-se\_sce\-ne\_item (секция сцены), par\-se\_time\_item (секция параметров времени),
par\-se\_spawn\_item (секция параметров мест появления),
par\-se\_for\-ces\_item (секция параметров социальных сил),
par\-se\_fov\_item (секция параметров поля зрения)
или par\-se\_den\-si\-ty\_map\_item (секция параметров плотностей потоков).
Каждая из этих функций читает из входного потока номер элемента конфигурации,
а потом в зависимости от элемента читает нужное количество параметров с помощью функций чтения элементарных типов.

В качестве функций чтения элементарных типов в модуле configuration реализованы:
par\-se\_u8 (чтение однобайтового беззнакового целого числа),
par\-se\_u16 (чтение двухбайтового беззнакового целого числа),
par\-se\_u32 (чтение четырехбайтового беззнакового целого числа),
par\-se\_f64 (чтение восьмибайтового числа с плавающей точкой),
par\-se\_string (чтение строки),
par\-se\_co\-or\-di\-na\-tes (чтение набора из четырех координат),
par\-se\_dis\-tri\-bu\-ti\-on (чтение элемента распределения).

\subsubsection{Выполнение симуляции}
\label{sec:development:core:simulation}

\subsubsection{Вспомогательные подмодули, используемые при симуляции}
\label{sec:development:core:utils}

При выполнении симуляции использовались некоторые вспомогательные подмодули в составе модуля utils.

Первым таким подмодулем является подмодуль linelg.

\subsubsection{Формирование сообщений о текущем состоянии симуляции модулю отображения результатов}
\label{sec:development:core:output}

За формирование сообщений о текущем состоянии симуляции отвечает подмодуль output.
Так же как и модуль simulation, при инициализации он принимает объект конфигурации, из которого он получает нужные ему элементы.

Формат сообщений модулю отображения результатов можно разбить на два отдельных сообщения: инициализирующее сообщение и сообщение о текущем состоянии.

Посылку инициализирующего сообщения осуществляет метод se\-nd\_in\-it.
В составе инициализирующего сообщения посылается информация в следующем порядке:
\begin{itemize}
  \item длина строки с именем svg файла схемы сооружения (беззнаковое число, 2 байта);
  \item строка с именем svg файла схемы сооружения;
  \item масштаб svg файла схемы сооружения, метров на пиксель (число с плавающей точкой, 8 байт);
  \item флаг наличия карт плотности пешеходных потоков: 1 "--- есть, 0 "--- нету (беззнаковое число, 1 байт);
  \item минимальная плотность пешеходных потоков (число с плавающей точкой, 8 байт);
  \item максимальная плотность пешеходных потоков (число с плавающей точкой, 8 байт).
\end{itemize}

После этого на каждом такте осуществляется посылка сообщения о текущем состоянии с помощью метода dump\_state.
Каждое сообщение о текущем состоянии состоит из следующих полей:
\begin{itemize}
  \item текущее время симуляции (число с плавающей точкой, 8 байт);
  \item в случае, если карты плотности пешеходных потоков включены: флаг наличия в данном сообщении информации о плотности пешеходных потоков (беззнаковое число, 1 байт);
  \item в случае, если флаг наличия информации о плотности пешеходных потоков установлен: количество точек с плотностью выше минимальной (беззнаковое число, 4 байта);
  \item в случае, если флаг наличия информации о плотности пешеходных потоков установлен: массив из точек с повышенной плотностью в формате
    координата по горизонтали (беззнаковое число, 2 байта), координата по вертикали (беззнаковое число, 2 байта), плотность (число с плавающей точкой, 8 байт);
  \item количество пешеходов (беззнаковое число, 4 байта);
  \item массив из координат пешеходов и их направлений в формате
    координата по горизонтали (беззнаковое число, 2 байта), координата по вертикали (беззнаковое число, 2 байта), направление (число с плавающей точкой, 8 байт).
\end{itemize}

Важным моментом является опциональное присутствие карты плотности в сообщении.
Это обусловлено тем, что расчет карты плотности достаточно трудоемкая задача, и делать данный расчет на каждой итерации симуляции не имеет смысла.
Вместо этого, расчет карты плотности производится каждую секунду модельного времени.

Также стоит упомянуть, что направление представляет собой угол от положительного направления оси абсцисс в радианах и имеет область значений от $0$ до $2\pi$.
